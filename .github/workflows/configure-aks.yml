name: Configure AKS Cluster

permissions:
  id-token: write
  contents: read

on:
  workflow_dispatch:
    inputs:
      argo_admin_group_id:
        description: "Argo Admin Group name (this group will be granted admin access in ArgoCD)"
        required: true
        default: "grp-aks-admin"

jobs:
  configure-kube:
    runs-on:
      group: vnet-spoke-production-engineers
    environment: Production-plan
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Azure Login (Federated credentials)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.CLIENTID }}
          tenant-id: ${{ vars.TENANTID }}
          allow-no-subscriptions: true

      - name: Set AKS Context
        uses: azure/aks-set-context@v4
        with:
          cluster-name: aksostbyengineeering001
          resource-group: rg-tf-aks

      - name: Install kubelogin
        run: |
          echo "Downloading kubelogin..."
          curl -L -o kubelogin.zip https://github.com/Azure/kubelogin/releases/download/v0.2.7/kubelogin-linux-amd64.zip
          unzip kubelogin.zip
          chmod +x bin/linux_amd64/kubelogin
          sudo mv bin/linux_amd64/kubelogin /usr/local/bin/kubelogin
          kubelogin --version

      - name: Convert kubeconfig for noninteractive login using azurecli mode
        run: |
          echo "Converting kubeconfig to noninteractive azurecli mode..."
          kubelogin convert-kubeconfig --login azurecli

      - name: Install ArgoCD
        run: |
          kubectl create namespace argocd || true
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

      - name: Wait for ArgoCD Server to be Ready
        run: |
          echo "Waiting for ArgoCD pods to be ready..."
          kubectl -n argocd rollout status deploy/argocd-server --timeout=300s    
      
          - name: Configure ArgoCD repository access with GitHub App
          env:
            GITHUB_APP_ID: ${{ secrets.OSTBYTESTORGARGOCDAPPID }}
            GITHUB_APP_INSTALLATION_ID: ${{ secrets.OSTBYTESTORGARGOCDINSTALLATIONID }}
            GITHUB_APP_PRIVATE_KEY: ${{ secrets.OSTBYTESTORGARGOCDKEY }}
          run: |
            echo "Configuring ArgoCD repository access with GitHub App..."
            
            # Create a secret containing GitHub App credentials
            cat <<EOF > github-app-secret.yaml
            apiVersion: v1
            kind: Secret
            metadata:
              name: github-app-creds
              namespace: argocd
            type: Opaque
            stringData:
              githubAppID: "${GITHUB_APP_ID}"
              githubAppInstallationID: "${GITHUB_APP_INSTALLATION_ID}"
              githubAppPrivateKey: |
            $(echo "$GITHUB_APP_PRIVATE_KEY" | sed 's/^/    /')
            EOF
            
            kubectl apply -f github-app-secret.yaml
            
            # Configure the repository in ArgoCD ConfigMap
            cat <<EOF > repo-cm-patch.yaml
            apiVersion: v1
            kind: ConfigMap
            metadata:
              name: argocd-cm
              namespace: argocd
            data:
              repositories: |
                - url: https://github.com/ostbytestorg/p-corp-engineers-iac.git
                  type: git
                  githubAppID:
                    name: github-app-creds
                    key: githubAppID
                  githubAppInstallationID:
                    name: github-app-creds
                    key: githubAppInstallationID
                  githubAppPrivateKey:
                    name: github-app-creds
                    key: githubAppPrivateKey
            EOF
            
            kubectl apply -f repo-cm-patch.yaml
            
            # Restart the repo server to apply changes
            kubectl rollout restart deployment argocd-repo-server -n argocd
            
            # Wait for repo server to be ready
            kubectl rollout status deployment argocd-repo-server -n argocd --timeout=120s
            
            echo "ArgoCD repository access configured successfully"    
            
      - name: Make scripts executable
        run: chmod +x ./ARGOCD/infra-appmanifests/apply-infra-apps.sh
          
      - name: Apply infrastructure application manifests
        run: ./ARGOCD/infra-appmanifests/apply-infra-apps.sh
      
      - name: Get Ingress Controller IP
        run: |
          echo "Getting Ingress Controller IP..."
          INGRESS_IP=$(kubectl get service -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "Ingress Controller IP: $INGRESS_IP"
          echo "INGRESS_IP=$INGRESS_IP" >> $GITHUB_ENV
      
      - name: Update or Create DNS A Record for ArgoCD
        run: |
          # Check if the A record exists
          echo "Checking for existing DNS record..."
          DNS_ZONE="middagsklubben.beer"
          DNS_RECORD_NAME="argocd"
          RESOURCE_GROUP="rg-tf-dns"
          TTL=60  # 1 minute TTL
      
          record_exists=$(az network dns record-set a list \
            --resource-group $RESOURCE_GROUP \
            --zone-name $DNS_ZONE \
            --query "[?name=='$DNS_RECORD_NAME']" \
            --output tsv)
      
          if [ -z "$record_exists" ]; then
            echo "Creating new DNS A record with TTL of $TTL seconds..."
            az network dns record-set a create \
              --resource-group $RESOURCE_GROUP \
              --zone-name $DNS_ZONE \
              --name $DNS_RECORD_NAME \
              --ttl $TTL
            
            az network dns record-set a add-record \
              --resource-group $RESOURCE_GROUP \
              --zone-name $DNS_ZONE \
              --record-set-name $DNS_RECORD_NAME \
              --ipv4-address ${{ env.INGRESS_IP }}
          else
            echo "Updating existing DNS A record with TTL of $TTL seconds..."
            az network dns record-set a update \
              --resource-group $RESOURCE_GROUP \
              --zone-name $DNS_ZONE \
              --name $DNS_RECORD_NAME \
              --set "aRecords[0].ipv4Address=${{ env.INGRESS_IP }}" \
              --ttl $TTL
          fi
      
          echo "DNS record for argocd.middagsklubben.beer now points to ${{ env.INGRESS_IP }} with TTL of $TTL seconds"