name: Configure AKS Cluster

permissions:
  id-token: write
  contents: read

on:
  workflow_dispatch:
    inputs:
      argo_admin_group_id:
        description: "Argo Admin Group name (this group will be granted admin access in ArgoCD)"
        required: true
        default: "grp-aks-admin"

jobs:
  configure-kube:
    runs-on:
      group: vnet-spoke-production-engineers
    environment: Production-plan
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Azure Login (Federated credentials)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.CLIENTID }}
          tenant-id: ${{ vars.TENANTID }}
          allow-no-subscriptions: true

      - name: Set AKS Context
        uses: azure/aks-set-context@v4
        with:
          cluster-name: aksostbyengineeering001
          resource-group: rg-tf-aks

      - name: Install kubelogin
        run: |
          echo "Downloading kubelogin..."
          curl -L -o kubelogin.zip https://github.com/Azure/kubelogin/releases/download/v0.2.7/kubelogin-linux-amd64.zip
          unzip kubelogin.zip
          chmod +x bin/linux_amd64/kubelogin
          sudo mv bin/linux_amd64/kubelogin /usr/local/bin/kubelogin
          kubelogin --version

      - name: Convert kubeconfig for noninteractive login using azurecli mode
        run: |
          echo "Converting kubeconfig to noninteractive azurecli mode..."
          kubelogin convert-kubeconfig --login azurecli
          
      - name: Make scripts executable
        run: chmod +x ./ARGOCD/infra-appmanifests/apply-infra-apps.sh
          
      - name: Apply infrastructure application manifests
        run: ./ARGOCD/infra-appmanifests/apply-infra-apps.sh
      
      - name: Get Ingress Controller IP
        run: |
          echo "Getting Ingress Controller IP..."
          INGRESS_IP=$(kubectl get service -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "Ingress Controller IP: $INGRESS_IP"
          echo "INGRESS_IP=$INGRESS_IP" >> $GITHUB_ENV
      
      - name: Update or Create DNS A Record for ArgoCD
        run: |
          # Check if the A record exists
          echo "Checking for existing DNS record..."
          DNS_ZONE="middagsklubben.beer"
          DNS_RECORD_NAME="argocd"
          RESOURCE_GROUP="rg-tf-dns"
          TTL=60  # 1 minute TTL
      
          record_exists=$(az network dns record-set a list \
            --resource-group $RESOURCE_GROUP \
            --zone-name $DNS_ZONE \
            --query "[?name=='$DNS_RECORD_NAME']" \
            --output tsv)
      
          if [ -z "$record_exists" ]; then
            echo "Creating new DNS A record with TTL of $TTL seconds..."
            az network dns record-set a create \
              --resource-group $RESOURCE_GROUP \
              --zone-name $DNS_ZONE \
              --name $DNS_RECORD_NAME \
              --ttl $TTL
            
            az network dns record-set a add-record \
              --resource-group $RESOURCE_GROUP \
              --zone-name $DNS_ZONE \
              --record-set-name $DNS_RECORD_NAME \
              --ipv4-address ${{ env.INGRESS_IP }}
          else
            echo "Updating existing DNS A record with TTL of $TTL seconds..."
            az network dns record-set a update \
              --resource-group $RESOURCE_GROUP \
              --zone-name $DNS_ZONE \
              --name $DNS_RECORD_NAME \
              --set "aRecords[0].ipv4Address=${{ env.INGRESS_IP }}" \
              --ttl $TTL
          fi
      
          echo "DNS record for argocd.middagsklubben.beer now points to ${{ env.INGRESS_IP }} with TTL of $TTL seconds"